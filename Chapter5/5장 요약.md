# 목차

- [Item 33 : 팩토리 함수 고려사항](#item-33--생성자-대신-팩토리-함수-고려사항)

## Item 33 : 생성자 대신 팩토리 함수 고려사항

Kotlin에서는 객체의 인스턴스를 생성하는데 다양한 방법이 있습니다. 기본 생성자 대신 팩토리 함수를 사용하여 객체를 생성하는 방법들 입니다.

### 팩토리 함수의 이점

팩토리 함수는 생성자와 달리 이름이 있어 객체가 어떻게 생성되고, 인수가 무엇인지를 더 명확하게 표현할 수 있습니다.  
또한, 팩토리 함수는 생성자와 달리 반환 유형의 모든 하위 유형의 객체를 반환할 수 있어 더 유연하게 사용할 수 있습니다.

### Companion Object factory function

`companion object`를 통해 팩토리 함수를 정의할 수 있습니다.   
이러한 접근법은 Java의 정적 팩토리 메서드와 동일한 방식이기에 Java 개발자들은 익숙할 수 있습니다.

```kotlin
companion object {
    fun <T> of(vararg element: T): MyList<T>? { /*...*/
    }
}
```

### Extension factory functions

`companion object` 함수처럼 작동하는 팩토리 함수를 생성하고 싶지만,
`companion object`를 수정할 수 없거나 별도의 파일에 새 함수를 명시하고 싶은 경우에 확장 함수를 정의하여 사용할 수 있습니다.

```kotlin
interface Tool {
    companion object { /*...*/ }
}

fun Tool.Companion.createBigTool(/*...*/): BigTool = { /*...*/ }
```

### Top-level functions

객체 생성 시 가장 일반적인 생성 방법으로 `listOf`, `setOf`, `mapOf` 등이 있습니다.

### Fake Constructors

Kotlin에서 생성자를 최상위 함수처럼 사용할 수 있으며 이 함수는 생성자처럼 보이고 동작합니다.
이러한 최상위 함수처럼 사용되는 생성자는 팩토리 함수의 모든 이점을 가지고 있기 때문에 종종 "Fake Constructors"라고 불립니다.
Fake Constructors를 선택하는 주된 이유는 인터페이스에 생성자가 필요하거나, reified type parameter가 필요한 경우입니다.

```kotlin
public inline fun <T> MutableList(
    size: Int,
    init: (index: Int) -> T
): MutableList<T> {
    val list = ArrayList<T>(size)
    repeat(size) { index -> list.add(init(index)) }
    return list
}
```

### Methods on a factory class

팩토리 클래스는 상태를 가질 수 있으므로 팩토리 함수보다 더 많은 기능을 제공할 수 있습니다.
팩토리 클래스는 캐싱을 활용하거나, 이전에 생성된 객체를 복제하여 객체 생성 속도를 향상시키는 등의 다양한 최적화나 기능을 도입할 수 있습니다.

```kotlin
class StudentsFactory {
    var nextId = 0
    fun next(name: String, surname: String) = Student(nextId++, name, surname)
}
```